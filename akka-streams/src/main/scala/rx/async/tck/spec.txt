Reactive-Streams SPI Specification
==================================

Clarification of terminology used throughout this document:
 "Publisher"   : an implementation of the `rx.async.spi.Publisher` interface
 "Subscriber"  : an implementation of the `rx.async.spi.Subscriber` interface
 "Subscription": an implementation of the `rx.async.spi.Subscription` interface
 "subscriber"  : a Subscriber which is currently subscribed, i.e. has an active Subscription
 Foo::bar      : an instance method `bar` on the class `Foo`


Specification Rules
-------------------

Publisher::subscribe(Subscriber)
  when Publisher is in `completed` state
    must not call `onSubscribe` on the given Subscriber
    must trigger a call to `onComplete` on the given Subscriber

  when Publisher is in `error` state
    must not call `onSubscribe` on the given Subscriber
    must trigger a call to `onError` on the given Subscriber

  when Publisher is neither in `completed` nor `error` state
    must trigger a call to `onSubscribe` on the given Subscriber if the Subscription is to be accepted
    must trigger a call to `onError` on the given Subscriber if the Subscription is to be rejected
    must reject the Subscription if the same Subscriber already has an active Subscription [1, 2]


Subscription::requestMore(Int)
  when Subscription is cancelled
    must throw a `java.lang.IllegalStateException`
  when Subscription is not cancelled
    must register the given number of additional elements to be produced to the respective subscriber
    must call `onError` if the total number of requested elements for the respective subscriber would overflow 2^63-1 [2]
    must throw a `java.lang.IllegalArgumentException` if the argument is <= 0
    is allowed to synchronously call `onNext` on this (or other) subscriber(s) if and only if the next element is already available
    is allowed to synchronously call `onComplete` or `onError` on this (or other) subscriber(s)


Subscription::cancel
  when Subscription is cancelled
    must throw a `java.lang.IllegalStateException`
  when Subscription is not cancelled
    the Publisher must eventually cease to call any methods on the corresponding subscriber
    the Publisher must eventually drop any references to the corresponding subscriber
    the Publisher must obey the "a Subscription::cancel happens before any subsequent Publisher::subscribe" rule [3]


A Publisher
  must not call `onNext`
    more times than the total number of elements that was previously requested with Subscription::requestMore by the corresponding subscriber
    after having issued an `onComplete` or `onError` call on a subscriber

  must produce the same elements in the same sequence for all its subscribers [4]
  must call `onComplete` on a subscriber after having produced the final stream element to it [5]
  must call `onComplete` on a subscriber at the earliest possible point in time [6]
  must start producing with the oldest still available element for a new subscriber
  must not call `onComplete` or `onError` more than once per subscriber


Subscriber::onSubscribe(Subscription), Subscriber::onNext(T)
  must asyncly schedule a respective event to the subscriber
  must not call any methods on the Subscription, the Publisher or any other Publishers or Subscribers


Subscriber::onComplete, Subscriber::onError(Throwable)
  must asyncly schedule a respective event to the Subscriber
  must not call any methods on the Subscription, the Publisher or any other Publishers or Subscribers
  must consider the Subscription cancelled after having received the event


A Subscriber
  must trigger an error when an `onSubscribe` event is received while a Subscription is still active [7]
  must call Subscription::cancel during shutdown if it still has an active Subscription
  must not call Subscription::requestMore on a cancelled Subscription
  must not call Subscription::cancel on a cancelled Subscription
  must be prepared to receive one or more `onNext` events after having called Subscription::cancel [8]
  must be prepared to receive an `onComplete` event with or without a preceding Subscription::requestMore call
  must be prepared to receive an `onError` event with or without a preceding Subscription::requestMore call


A Processor
  must obey all Publisher rules on its producing side
  must obey all Subscriber rules on its consuming side
  must cancel its upstream Subscription if its last downstream Subscription has been cancelled
  must immediately pass on `onError` events received from its upstream to its downstream [9]
  must be prepared to receive incoming elements from its upstream even after its last downstream Subscription has been cancelled
  must be prepared to receive incoming elements from its upstream even if a downstream subscriber has not requested anything yet

Generally
  all SPI methods should neither block nor run expensive logic on the calling thread [10]


[1] Reference equality is to be used for establishing whether two Subscribers are the "same".
[2] with a `java.lang.IllegalStateException`
[3] I.e. when seen from the perspective on one thread a `subscribe(...)` on a Publisher must not "overtake"
    a `cancel()` on a Subscription from that Publisher. Without this happens-before rule cancelling a Subscription and
    immediately resubscribing to a Publisher might fail as subscribing the same Subscriber twice is disallowed.
[4] Producing the stream elements at (temporarily) differing rates to different subscribers is allowed.
[5] The final stream element must be the same for all Subscribers.
[6] In particular a Publisher should not wait for another Subscription::requestMore call before calling `onComplete`
    if the information that no more elements will follow is already available before.
[7] I.e. one Subscriber cannot be subscribed to multiple Publishers at the same time.
[8] if there are still requested elements pending
[9] I.e. errors must not be treated as "in-stream" events that are allowed to be buffered.
[10] I.e. they are supposed to return control to the caller quickly.